# 数据结构+算法

递归:
1. 找出递归出口
2. 找出递归体
3. 大问题，分成小问题
4. 或许能用栈解决


冒泡排序：
单次遍历，交换大小，最大的在最后  （升序）
单次遍历，交换大小，最小的在最后  （降序）

快速排序:
解法1:
L,R,P
L -> R, L直到找到比自己大的,Stop,如果碰撞到R，并不会停止
R -> L, R直到找到比自己小的,Stop,停止并交换, 如果碰撞到L,停止并交换 (确保L的值>P的值),如果已经被L标记，停止并交换

解法2: (个人觉得更加方便)
i=L; j = R; 将基准数挖出形成第一个坑a[i]。
j--由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。
i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。
再重复执行2，3二步，直到i==j，将基准数填入a[i]中。

插入排序:
一个有序数组，一个无序数组， 默认取第一个元素放到有序数组, 假设最大
然后依次取无序数组，与有序数组比较 (升序，降序)，并做插入操作
比较完毕，则有序数组排序完毕

选择排序，线性搜索最小，然后交换放到数组位置，逐个交换；
二分查找，在有序的数组查找, 顾名思义，(begin + endpos) / 2, 也是分而治之的概念;
线性查找，遍历查找;

归并排序:
分而治之,合并两个有序数组

# LeeCode 磨刀霍霍
